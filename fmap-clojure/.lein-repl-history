(use 'fmap-clojure.core :reload)
(star-channel "a" inc 1)
(star-channel "a" inc [1])
(use 'fmap-clojure.core :reload)
(star-channel "a" inc [1])
(use 'fmap-clojure.core :reload)
(star-channel "a" inc [1])
(use 'fmap-clojure.core :reload)
(star-channel "a" inc [1])
(use 'fmap-clojure.core :reload)
(star-channel "a" inc [1])
(use 'fmap-clojure.core :reload)
(star-channel "a" inc [1])
(use 'fmap-clojure.core :reload)
(star-channel "a" inc [1])
(use 'fmap-clojure.core :reload)
(star-channel "a" inc [1])
(use 'fmap-clojure.core :reload)
(star-channel "a" inc [1])
(use 'fmap-clojure.core :reload)
(star-channel "a" inc [1])
(use 'fmap-clojure.core :reload)
(star-channel "a" inc [1])
(use 'fmap-clojure.core :reload)
(star-channel "a" inc [1])
(use 'fmap-clojure.core :reload)
(star-channel "a" inc [1])
(use 'fmap-clojure.core :reload)
(star-channel "a" inc [1])
(use 'fmap-clojure.core :reload)
(star-channel "a" inc [1])
(use 'fmap-clojure.core :reload)
(star-channel "a" inc [1])
(use 'fmap-clojure.core :reload)
(star-channel "a" inc [1])
(use 'fmap-clojure.core :reload)
(star-channel "a" inc 1)
(use 'fmap-clojure.core :reload)
(star-channel "a" inc 1)
(use 'fmap-clojure.core)
(use 'fmap-clojure.core :reload)
(import 'java.io.FileInputStream)
(import 'java.io.File)
(def fin (FileInputStream. (File. "/tmp/test.txt")))
(def shareio (IO fin))
shareio
(fmap shareio #(.read %))
shared-io-star-chan 
(use 'fmap-clojure.core)
(<*> [inc] [1])
(use 'fmap-clojure.core)
(<*> [inc] [1 [1 2 3 4]])
(use 'fmap-clojure.core)
(<*> [inc] [1 [1 2 3 4]])
(<*> [inc] [1 2 3 4])
(<*> [inc] [1])
(<*> [inc] [1 [1 2 3 4]])
(use 'fmap-clojure.core)
(fmap [1 2 3] count)
(fmap (Just. [1 2 3]) count)
(->Just 1)
(Just 1)
(Just. 1)
(fmap (->Just [1 2 3]) count)
(-> (fmap (->Just [1 2 3]) count) str)
(-> (fmap (->Just [1 2 3]) count) (fmap str))
(use 'fmap-clojure.core :reload)
(-> (fmap (->Just [1 2 3]) count) (fmap str))
(-> (fmap (->Just [1 2 3]) count) (fmap str) lift)
(<*> [inc dec] [1 2])
(<*> [inc] [1 [2 3]])
(doc repeat)
(doc repeatedly)
(partial repeatedly 10)
(
(partial repeatedly 10) #(1))
(def t
(partial repeatedly 10))
t
(t 1)
(t (fn [] (+ 1 1)))
(doc dotimes)
(partial (dotimes [i 10]))
(dotimes)
(doc repeat)
(repeat 10 1)
(repeat 10 (+ 1 1))
(use 'fmap-clojure.core)
(fmap "a" (partial repeat 10))
(fmap (+ 1 2) (partial repeat 10))
(fmap [1 2]  (partial repeat 10))
(fmap [1 2]  (repeat 10))
(repeat 10)
(fmap "a" (partial repeat 10))
(doc doall)
(fmap "a" prn)
(fmap (fmap "a" prn) doall)
(fmap (fmap "a" prn) (partial (repeat 10)))
(fmap (fmap (fmap "a" prn) (partial (repeat 10))) doall)
(fmap "a" prn)
(doc repeat)
(repeat 10 (prn "10")
)
(repeat 10 (prn "10"))
(doc cycle)
(doc repeatedly)
(fmap "a" (partial repeat 10))
(doc repeatedly)
(fmap "a" (partial repeat 10))
(fmap "a" (partial repeatedly 10))
(fmap (fn [] "a") (partial repeatedly 10))
(fmap (->Just (fn [] "a")) (partial repeatedly 10))
(doc repeat)
(doc repeatedly)
(fmap 1 (-> inc)) 
(doc repeat) 
(repeatedly 10 inc)
(repeatedly 10 #(+ 1 2))
(-> (+ 1 2) (repeatedly 10 ))
(->> (+ 1 2) (repeatedly 10 ))
(->> (+ 1 2) (doseq [i 10]))
(->> (+ 1 2) (doseq [i 10] ))
(second [1 2 ])
(defmacro m [ & body ]
  (first body))
(macroexpand '(m (inc 1)))
(use 'fmap-clojure.core :reload)
(>>* 1 inc)
(macroexpand '(>>* 1 inc))
(defmacro >>* [& body]
  (cond 
       (= (count body) 2) 
       `(>>= (first body) (second body))
       (or (= (count body) 1) (= (count body) 0))
        body
       :else
       `(>>* (>>= (first body) (second body)))))
(use 'fmap-clojure.core :reload)
(macroexpand '(>>* 1 inc))
(use 'fmap-clojure.core :reload)
(macroexpand '(>>* 1 inc))
(use 'fmap-clojure.core :reload)
(macroexpand '(>>* 1 inc))
(use 'fmap-clojure.core :reload)
(macroexpand '(>>* 1 inc))
(use 'fmap-clojure.core :reload)
(macroexpand '(>>* 1 inc))
(use 'fmap-clojure.core :reload)
(macroexpand '(>>* 1 inc))
(use 'fmap-clojure.core :reload)
(macroexpand '(>>* 1 inc))
(use 'fmap-clojure.core :reload)
(macroexpand '(>>* 1 inc))
(>>* 1 inc)
(use 'fmap-clojure.core :reload)
(macroexpand '(>>* 1 inc))
(>>* 1 inc)
(use 'fmap-clojure.core :reload)
(macroexpand '(>>* 1 inc))
(>>* 1 inc)
(use 'fmap-clojure.core :reload)
(macroexpand '(>>* 1 inc))
(>>* 1 inc)
(use 'fmap-clojure.core :reload)
(macroexpand '(>>* 1 inc))
(use 'fmap-clojure.core :reload)
(macroexpand '(>>* 1 inc))
(>>* 1 inc)
(use 'fmap-clojure.core :reload)
(macroexpand '(>>* 1 inc) dec)
(macroexpand '(>>* 1 inc dec))
(drop 2 [1 2 3])
(use 'fmap-clojure.core :reload)
(macroexpand '(>>* 1 inc dec))
(>>* 1 inc)
(>>* 1 inc dec)
(use 'fmap-clojure.core :reload)
(macroexpand '(>>* 1 inc dec))
(>>* 1 inc dec)
(use 'fmap-clojure.core :reload)
(macroexpand '(>>* 1 inc dec))
(drop 2 [1 2 3])
(use 'fmap-clojure.core :reload)
(macroexpand '(>>* 1 inc dec))
(>>* 1 inc dec)
(use 'fmap-clojure.core :reload)
(>>* 1 inc dec)
(use 'fmap-clojure.core :reload)
(>>* 1 inc dec)
(use 'fmap-clojure.core :reload)
(>>* 1 inc dec)
(doc cons)
(use 'fmap-clojure.core :reload)
(>>* 1 inc dec)
(use 'fmap-clojure.core :reload)
(>>* 1 inc dec)
(use 'fmap-clojure.core :reload)
(>>* 1 inc dec)
(use 'fmap-clojure.core :reload)
(>>* 1 inc dec)
(doc conj)
(conj [1 2] 3 4)
(conj [1 2] 3 [4])
(doc concat)
(concat 1 2 [3 4] 5)
(concat 1 2 [3 4])
(concat [3 4])
(concat [3 4] [1 2])
(concat [3 4] 1 2)
(doc cons)
(use 'fmap-clojure.core :reload)
(>>* 1 inc dec)
(cons '>>* 1 inc)
(cons 1 [2 3])
(defmacro m [] (cons '>>* 1 inc)
)
(m 1 inc)
(macroexpand '(m 1 inc))
(defmacro m [& n] (cons '>>* 1 inc)
(macroexpand '(m 1 inc))
)
(defmacro m [& n] (cons '>>* 1 inc))
(macroexpand '(m 1 inc))
(defmacro m [& n] (cons '>>* 1 inc))
(defmacro m [& n] (cons '>>* 1 [inc]))
(macroexpand '(m 1 inc))
(defmacro m [& n] (cons '>>* [1 inc]))
(macroexpand '(m 1 inc))
((macroexpand '(m 1 inc)))
(macroexpand '(m 1 inc))
(defmacro m [& n] (cons 'fmap [1 inc]))
(macroexpand '(m 1 inc))
((macroexpand '(m 1 inc)))
(m 1 inc)
(use 'fmap-clojure.core :reload)
(>>* 1 inc dec)
(use 'fmap-clojure.core :reload)
(>>* 1 inc dec)
(use 'fmap-clojure.core :reload)
(>>* 1 inc dec)
(use 'fmap-clojure.core :reload)
(>>* 1 inc dec)
(>>* 1 )
(>>* 1 inc dec)
(use 'fmap-clojure.core :reload)
(>>* 1 )
(use 'fmap-clojure.core :reload)
(>>* 1 )
(use 'fmap-clojure.core :reload)
(>>* 1 )
(use 'fmap-clojure.core :reload)
(>>* 1 )
(>>* (inc 1) )
(use 'fmap-clojure.core :reload)
(>>* (inc 1) )
(defmacro f [& n] n)
(f inc)
(f inc 1)
(f (inc 1))
(f 1)
f
(doc f)
(use 'fmap-clojure.core :reload)
(>>* (inc 1) )
(use 'fmap-clojure.core :reload)
(>>=* [1 2 3] inc )
(use 'fmap-clojure.core :reload)
(>>=* [1 2 3] inc )
(>>=* [1 2 3] inc dec)
(Just 1)
(Just. 1)
(->Just 1)
(use 'fmap-clojure.core :reload)
(just 1)
(just 2)
(>>=* [1 2 3] inc dec just)
(use 'fmap-clojure.core :reload)
(>>=* [1 2 3] inc dec just)
(use 'fmap-clojure.core :reload)
(>>=* [1 2 3] inc dec just)
(mapcat inc [1 2])
(map inc [1 2])
(doc mapcat)
(mapcat inc [1 2 3])
(doc flatten)
(flatten [1 2])
(flatten [1 2 [3]])
(doc concat)
(concat [1 2 3])
(concat [1 2 3] 2)
(>>=* [1 2 3] inc dec just)
(use 'fmap-clojure.core :reload)
(>>=* [1 2 3] inc dec just)
(>>=* [1 2 3] inc dec 'just)
(use 'fmap-clojure.core :reload)
(>>=* [1 2 3] inc dec 'just)
(use 'fmap-clojure.core :reload)
(>>=* [1 2 3] inc dec 'just)
(use 'fmap-clojure.core :reload)
(>>=* [1 2 3] inc dec 'just)
(use 'fmap-clojure.core :reload)
(>>=* [1 2 3] inc dec 'just)
(= 'just (quote just))
(use 'fmap-clojure.core :reload)
(= 'just (quote just))
(>>=* [1 2 3] inc dec 'just)
(use 'fmap-clojure.core :reload)
(>>=* [1 2 3] inc dec 'just)
(use 'fmap-clojure.core :reload)
(>>=* [1 2 3] inc dec 'just)
(>>=* [1 2 3] inc dec :just)
(use 'fmap-clojure.core :reload)
(>>=* [1 2 3] inc dec :just)
(use 'fmap-clojure.core :reload)
(>>=* [1 2 3] inc dec :just)
(use 'fmap-clojure.core :reload)
(>>=* [1 2 3] inc dec :just)
(use 'fmap-clojure.core :reload)
(>>=* [1 2 3] inc dec :just)
(>>=* [1 2 3] inc dec :just count)
(>>=* [1 2 3] inc dec :lift)
(use 'fmap-clojure.core :reload)
(>>=* [1 2 3] inc dec :lift)
(doc nth)
(nth 1 [1 2 3 4])
(nth [1 2 3 4] 1)
(nth [1 2 3 4] 2)
(nth [1 2 3 4] 0)
(use 'fmap-clojure.core :reload)
(>>=* [1 2 3] inc dec :apply count)
(>>=* [1 2 3] :apply count)
(macroexpand '(>>=* [1 2 3] :apply count))
(macroexpand-1 '(>>=* [1 2 3] :apply count))
(macroexpand '(>>=* [1 2 3] :apply count))
(use 'fmap-clojure.core :reload)
(>>=* [1 2 3] :apply count)
(use 'fmap-clojure.core :reload)
(>>=* [1 2 3] :apply count)
(>>=* [1 2 3] :apply)
(use 'fmap-clojure.core :reload)
(>>=* [1 2 3] :just)
(>>=* [1 2 3] :just inc)
(>>=* [1 2 3] inc :just)
(>>=* [1 2 3] inc :lift)
(>>=* [1 2 3] inc :just)
(>>=* [1 2 3] inc :just inc)
(>>=* [1 2 3] inc :just)
(>>= (->Just [1 2 3]) count)
(use 'fmap-clojure.core :reload)
(>>= (->Just [1 2 3]) count)
(>>=* [1 2 3] inc :just)
(>>=* [1 2 3] inc :just count)
(nth 10 [1 2])
(nth [1 2] 10)
(1 [2 3])
([2 3] 1)
('(2 3) 1)
([2 3] 10)
(doc apply)
(apply count [1 2 3])
(apply count [[1 2 3]])
(apply inc [1 2 3])
(apply str [1 2 3])
(apply inc 1)
(apply inc [1])
(just 1)
(use 'fmap-clojure.core)
(use 'fmap-clojure.core :reload)
(cons 1 2)
(list 1 2)
(use 'fmap-clojure.core :reload)
(>>=* 1 :apply inc)
(use 'fmap-clojure.core :reload)
(>>=* 1 :apply inc)
(macroexpand '(>>=* 1 :apply inc))
(use 'fmap-clojure.core :reload)
(macroexpand '(>>=* 1 :apply inc))
(use 'fmap-clojure.core :reload)
(macroexpand '(>>=* 1 :apply inc))
(>>=* 1 :apply inc)
(use 'fmap-clojure.core :reload)
(>>=* 1 :apply inc)
(use 'fmap-clojure.core :reload)
(>>=* 1 :apply inc)
(use 'fmap-clojure.core :reload)
(>>=* 1 :apply inc)
(macroexpand '(>>=* 1 :apply inc))
(use 'fmap-clojure.core :reload)
(macroexpand '(>>=* 1 :apply inc))
(>>=* 1 :apply inc)
(inc (lift 1))
(use 'fmap-clojure.core :reload)
(>>=* 1 :apply inc)
(>>=* (inc (lift 1)))
(use 'fmap-clojure.core :reload)
(>>=* (inc (lift 1)))
(use 'fmap-clojure.core :reload)
(>>=* (inc (lift 1)))
(use 'fmap-clojure.core :reload)
(>>=* (inc (lift 1)))
(use 'fmap-clojure.core :reload)
(macroexpand '(>>=* 1 :apply inc))
(use 'fmap-clojure.core :reload)
(macroexpand '(>>=* 1 :apply inc))
(use 'fmap-clojure.core :reload)
(macroexpand '(>>=* 1 :apply inc))
(>>=* (inc (lift 1)))
(>>=* 1 inc)
(>>=* 1 :apply inc)
(>>=* [1 2 3] :apply count)
(>>=* 1 inc)
(macroexpand '(>>=* 1 inc))
(>>=* (>>= 1 inc))
(macroexpand '(>>=* 1 inc))
(use 'fmap-clojure.core :reload)
(macroexpand '(>>=* 1 inc))
(>>=* (>>= 1 inc))
(>>=* 1 inc)
(>>=* 1 dec inc)
(>>=* [1 2 3] inc)
(>>=* [1 2 3] inc dec :apply count)
(>>= [1 2 3] inc)
(>>= (->Just [1 2 3]) inc)
(>>= (->Just [1 2 3]) str)
(>>= (->Just [1 2 3]) )
(>>= (->Just [1 2 3]) inc)
(>>= (->Just [1 2 3]) count)
(use 'fmap-clojure.core :reload)
(>>= (->Just [1 2 3]) count)
(>>=* [1 2 3] :just)
(>>=* [1 2 3] :just count)
(>>=* [1 2 3] :just count lift)
(>>=* [1 2 3] :just count)
(use 'fmap-clojure.core :reload)
(>>=* [1 2 3] :just count)
(>>=* [1 2 3] :just count :lift)
(>>=* [1 2 3] inc dec :apply str)
(>>=* [1 2 3] inc dec :apply inc)
(>>=* [1 2 3] inc dec :just count :lift)
(>>=* [1 2 3] inc dec :just count)
(>>=* [1 2 3] inc dec str)
(>>= (>>= [1 2 3] inc) dec)
(>>=* [1 2 3] count)
(>>=* [1 2 3] inc count)
(>>=* [1 2 3] inc seq count)
(>>=* [1 2 3] inc vect count)
(doc vector)
(>>=* [1 2 3] inc vector count)
(>>=* [1 2 3] inc vector :just count)
(>>=* [1 2 3] inc vector :just count :lift)
(use 'fmap-clojure.core :reload)
`just
'`just
(use 'fmap-clojure.core :reload)
(>>=* [1 2 3] inc vector :just count :lift)
(use 'fmap-clojure.core :reload)
(>>=* [1 2 3] inc vector :just count :lift)
(macroexpand '(>>=* [1 2 3] inc vector :just count :lift))
